@model<tdc2>
@include "tdc2_model.pli"
@include "sat_tdc2_input.pli"

def main()
{
	call sat_tdc2(N,P);
}

def sat_tdc2(n,p)
{
  call init_cells(n,p);
  call init_multisets(n,p);
  call init_input(n,p);
  call init_rules(n,p);
}


def init_cells(n,p)
{
	@mu = [ ]'0;
	@mu(0) += [ ]'{i} : 1<= i <= n*p + 3;
}

def init_multisets(n,p)
{
	@ms(0) += alpha{k} : n*p <= k <= 2*n*p+2;
	@ms(0) += beta{k} : 1<= k <=2*n*p+3;
	@ms(0) += gamma{k} : 1<= k <= 2*n*p+5;
	@ms(0) += x{i,j,k}, nx{i,j,k}, sx{i,j,k} : 1<=i<=n,1<=j<=p,n*p+1<=k<=2*n*p;
	@ms({n*p+1}) += yes, no, beta{0}, gamma{0};
	@ms({n*p+2}) += a{i,j} : 1<=i<=n, 1<=j<=p;
	@ms({n*p+2}) += c{j} : 1<=j<=p;
	@ms({n*p+3}) += alpha{0};
}

def init_rules(n,p)
{
	/*****************************************************************************/
	/* 1.- Rules to generate p copies of the 2^n true possible truth assignments */
	/*****************************************************************************/
	
	[a{i,j}]'{n*p+2} --> [T{i,j}] [F{i,j}] : 1 <= i <= n, 1<= j <= p;
	[T{i,j}, F{i,k}]'{n*p+2} <--> []'0 : 1<= i <= n, 1<=j<=p, 1<=k<=p;
	
	/***************************************************/
	/* 2.- Rules to generate 2^(np) copies of cod(phi) */
	/***************************************************/
	{
		[x{i,j,0}]'{n*p+1} <--> [ ]'{i+n*(j-1)};
		[nx{i,j,0}]'{n*p+1} <--> [ ]'{i+n*(j-1)};
		[sx{i,j,0}]'{n*p+1} <--> [ ]'{i+n*(j-1)};
	} : 1<=i<=n, 1<=j<=p;

	{
		[x{i,j,k}]'{i+n*(j-1)} --> [x{i,j,k+1}] [x{i,j,k+1}];
		[nx{i,j,k}]'{i+n*(j-1)} --> [nx{i,j,k+1}] [nx{i,j,k+1}];
		[sx{i,j,k}]'{i+n*(j-1)} --> [sx{i,j,k+1}] [sx{i,j,k+1}];
	
	} : 1<=i<=n, 1<=j<=p, 0<=k<= n*p-1;
	
	{
		[x{i,j,k}]'{i+n*(j-1)} <--> [x{i,j,k+1}]'0;
		[nx{i,j,k}]'{i+n*(j-1)} <--> [nx{i,j,k+1}]'0;
		[sx{i,j,k}]'{i+n*(j-1)} <--> [sx{i,j,k+1}]'0;
	} : 1<=i<=n, 1<=j<=p, n*p <= k <= 2*n*p-1;
	
	/**************************************************/
	/* 3.- Rules to check which clauses are satisfied */
	/**************************************************/
	
	{
		[T{i,j}]'{n*p+2} <--> [x{i,j,2*n*p}]'{i+n*(j-1)};
		[F{i,j}]'{n*p+2} <--> [nx{i,j,2*n*p}]'{i+n*(j-1)};
	} : 1<=i<=n, 1<=j<=p;
	
	{
		[c{j},x{i,j,2*n*p}]'{n*p+2} <--> [ ]'0;
		[c{j},nx{i,j,2*n*p}]'{n*p+2} <--> [ ]'0;
	} : 1<=i<=n, 1<=j<=p;
	
	
	[alpha{k}]'{n*p+3} --> [alpha{k+1}] [alpha{k+1}] : 0<=k<= n*p-1;
	
	[alpha{n*p+k}]'{n*p+3} <--> [alpha{n*p+k+1}]'0 : n*p<=k<=n*p+1;
	[beta{k}]'{n*p+1} <--> [beta{k+1}]'0 : 0<=k<= 2*n*p+4;
	[gamma{k}]'{n*p+1} <--> [gamma{k+1}]'0 : 0<= k<= 2*n*p+4;
	[ ]'{n*p+2} <--> [alpha{2*n*p+2}]'{n*p+3};
	[alpha{2*n*p+2},c{j}]'{n*p+2} <--> [ ]'0 : 1<=j<=p;

	/*****************************************/
	/* 4.- Rules to return a negative answer */
	/*****************************************/
	
	[beta{2*n*p+4},gamma{2*n*p+5}]'{n*p+1} <--> [ ]'{n*p+3};
	[no]'{n*p+1} <--> [beta{2*n*p+4}]'{n*p+3};
	[no]'{n*p+3} <--> [ ]'0;
	
	/*****************************************/
	/* 5.- Rules to return a positive answer */
	/*****************************************/	
	[alpha{2*n*p+1}]'{n*p+2} <--> [beta{2*n*p+4}]'{n*p+1};
	[beta{2*n*p+4}]'{n*p+2} <--> [yes]'{n*p+1};
	[yes]'{n*p+2} <--> []'0;

}





